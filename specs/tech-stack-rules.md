# 🚀 AI 기반 LMS 플랫폼 기술 스택 및 개발 규칙

---
description: "AI 기반 LMS 플랫폼의 기술 스택 규칙 및 개발 표준"
globs: ["*.js", "*.jsx", "*.ts", "*.tsx", "*.py", "*.html", "*.css", "*.scss"]
alwaysApply: false
autoAttach: true
priority: 3
requires: []
---

## 📌 프로젝트 컨텍스트 정의

- **프로젝트명**: AI-LMS
- **프로젝트 설명**: AI 기반 개인화 학습 경험을 제공하는 클라우드 기반 학습관리시스템
- **프로젝트 단계**: MVP
- **핵심 기능**: 
  1. AI 기반 학습 경로 추천
  2. AI 챗봇 튜터 
  3. 데이터 분석 대시보드
- **예상 사용자/고객**: 교육 기관 및 기업의 교육 관리자, 강사/교수자, 학습자/수강생
- **도메인 특성**: 교육 기술(EdTech), 학습 관리
- **팀 구성**: 풀스택 개발자 3명, UX/UI 디자이너 1명, 인프라 엔지니어 1명, 프로젝트 매니저 1명

## 💻 기술 스택 정의

### 1. 프론트엔드
- **프레임워크/라이브러리**: [자동화 가능] React 18.x를 사용해야 한다(must). React는 컴포넌트 기반 아키텍처로 UI 재사용성을 높이고 상태 관리가 용이하기 때문이다.
- **상태 관리**: [자동화 가능] Redux Toolkit을 사용해야 한다(must). 전역 상태 관리와 비동기 작업 처리를 단순화하고 예측 가능한 상태 흐름을 제공하기 때문이다.
- **스타일링 방법**: [자동화 가능] TailwindCSS를 사용해야 한다(must). 유틸리티 우선 접근 방식으로 개발 속도를 높이고 일관된 디자인 시스템을 구현할 수 있기 때문이다.

### 2. 백엔드/서버
- **서버 기술/프레임워크**: [자동화 가능] Django 5.x와 Django REST Framework를 사용해야 한다(must). 빠른 개발과 보안, ORM, 관리자 패널 등 필요한 기능을 모두 제공하기 때문이다.
- **API 설계 패턴**: [자동화 가능] RESTful API 설계 원칙을 따라야 한다(must). 클라이언트-서버 분리와 상태 비저장성으로 확장성을 확보하고 표준화된 인터페이스를 제공하기 때문이다.
- **인증/보안 방식**: [자동화 가능] JWT 토큰 기반 인증을 구현해야 한다(must). 서버 부하를 줄이고 마이크로서비스 아키텍처에 적합한 인증 방식이기 때문이다.

### 3. 데이터베이스
- **데이터베이스 종류/버전**: [자동화 가능] PostgreSQL 15.x를 주 데이터베이스로 사용해야 한다(must). 복잡한 쿼리, JSON 지원, 트랜잭션 안정성이 우수하기 때문이다.
- **캐싱 시스템**: [자동화 가능] Redis를 캐싱 및 세션 관리에 사용해야 한다(must). 빠른 응답 시간과 분산 환경에서의 데이터 공유가 용이하기 때문이다.
- **스키마 설계 원칙**: [자동화 가능] 정규화된 스키마 설계 후 필요에 따라 비정규화를 적용해야 한다(should). 데이터 무결성을 유지하면서도 성능을 최적화할 수 있기 때문이다.

### 4. 인프라
- **배포 환경**: [자동화 가능] AWS(EC2, S3, RDS)를 사용해야 한다(must). 확장성이 좋고 다양한 서비스를 통합적으로 활용할 수 있기 때문이다.
- **컨테이너화**: [자동화 가능] Docker와 docker-compose를 사용해야 한다(must). 개발과 프로덕션 환경의 일관성을 보장하고 배포 프로세스를 단순화할 수 있기 때문이다.
- **웹 서버**: [자동화 가능] Nginx를 웹 서버 및 리버스 프록시로 사용해야 한다(must). 정적 파일 서빙 성능이 우수하고 로드 밸런싱 기능을 제공하기 때문이다.

### 5. 테스트
- **테스트 도구**: [자동화 가능] 프론트엔드는 Jest와 React Testing Library, 백엔드는 PyTest를 사용해야 한다(must). 각 영역에 최적화된 테스트 도구로 안정성을 확보할 수 있기 때문이다.
- **테스트 범위 요구사항**: [자동화 가능] 핵심 모듈은 단위 테스트 및 통합 테스트를 모두 작성해야 한다(must). 핵심 기능의 안정성이 전체 시스템 안정성에 직결되기 때문이다.

## 📝 코딩 규칙 및 개발 프로세스

### 1. 코드 구조
- **파일/폴더 구조 규칙**: [자동화 가능] 프론트엔드는 기능별 모듈 분리, 백엔드는 Django 앱 단위로 분리해야 한다(must). 코드의 가독성과 유지보수성을 높이기 위함이다.
```
frontend/
  ├── src/
  │   ├── components/
  │   │   ├── common/
  │   │   ├── courses/
  │   │   └── dashboard/
  │   ├── features/
  │   ├── api/
  │   └── utils/
backend/
  ├── config/
  ├── apps/
  │   ├── users/
  │   ├── courses/
  │   └── analytics/
```
- **모듈화 전략**: [자동화 가능] 고수준의 추상화와 단일 책임 원칙을 따라야 한다(should). 코드 재사용성을 높이고 유지보수를 용이하게 하기 위함이다.

### 2. 코딩 스타일
- **포맷팅 규칙**: [자동화 가능] 프론트엔드는 ESLint와 Prettier, 백엔드는 Black 및 isort를 사용해야 한다(must). 일관된 코드 스타일로 가독성을 향상시키기 위함이다.
- **문서화 표준**: [자동화 가능] JSDoc(JS), docstring(Python) 형식으로 핵심 함수와 클래스를 문서화해야 한다(must). 코드의 용도와 동작을 명확히 이해할 수 있도록 하기 위함이다.
- **네이밍 컨벤션**: [자동화 가능] JS/TS는 camelCase, React 컴포넌트는 PascalCase, Python은 snake_case, CSS 클래스는 kebab-case를 사용해야 한다(must). 언어별 관례를 따라 일관성을 유지하기 위함이다.

### 3. 품질 관리
- **코드 리뷰 프로세스**: [자동화 가능] 모든 코드는 최소 1명 이상의 리뷰를 받아야 한다(must). 코드 품질을 높이고 지식 공유를 촉진하기 위함이다.
- **정적 분석 도구**: [자동화 가능] CI 파이프라인에서 ESLint, PyLint, SonarQube를 실행해야 한다(must). 잠재적 버그와 코드 스멜을 조기에 발견하기 위함이다.

## 🤝 협업 워크플로우

- **버전 관리 전략**: [자동화 가능] GitHub Flow를 사용하고, 기능별 브랜치에서 작업 후 메인 브랜치로 병합해야 한다(must). 지속적 배포에 적합하고 브랜치 관리가 단순화되기 때문이다.
- **PR/MR 요구사항**: [자동화 가능] PR 템플릿을 사용하고, 모든 PR은 CI 테스트를 통과해야 한다(must). 일관된 리뷰 프로세스와 품질 보장을 위함이다.

## 🔄 품질 기준 및 우선순위

### 1. 품질 기준
- **테스트 커버리지 목표**: [자동화 가능] 핵심 모듈은 최소 80% 이상의 테스트 커버리지를 유지해야 한다(must). 핵심 기능의 안정성을 보장하기 위함이다.
- **코드 복잡도 기준**: 순환 복잡도(Cyclomatic Complexity)는 함수당 10 이하로 유지해야 한다(should). 코드 이해와 테스트가 용이하도록 하기 위함이다.
- **문서화 수준 요구사항**: README와 API 문서를 최신 상태로 유지해야 한다(must). 개발자 온보딩 시간을 단축하고 API 활용을 용이하게 하기 위함이다.

### 2. 구현 패턴
- **오류 처리 전략**: [자동화 가능] 프론트엔드에서는 try-catch, 백엔드에서는 전역 예외 처리기를 사용해야 한다(must). 일관된 오류 처리로 사용자 경험과 디버깅을 개선하기 위함이다.
- **비동기 처리 패턴**: [자동화 가능] 프론트엔드에서는 async/await와 Redux-Thunk, 백엔드에서는 비동기 뷰를 권장한다(should). 코드 가독성을 높이고 콜백 지옥을 방지하기 위함이다.
- **의존성 관리 방식**: [자동화 가능] 프론트엔드는 yarn, 백엔드는 poetry를 사용해야 한다(must). 의존성 잠금과 재현 가능한 빌드를 보장하기 위함이다.

### 3. 최적화 우선순위
- **개발 속도 vs 코드 품질**: MVP 단계에서는 핵심 기능의 품질을 유지하면서 개발 속도를 우선시한다(should). 빠른 시장 검증과 사용자 피드백 수집을 위함이다.
- **성능 vs 가독성**: 대부분의 코드는 가독성을 우선하되, 성능 크리티컬 경로는 최적화해야 한다(should). 유지보수성과 성능의 균형을 위함이다.
- **유연성 vs 단순성**: 확장 가능성이 높은 핵심 모듈은 유연하게, 그 외 영역은 단순하게 설계한다(should). 불필요한 복잡성 없이 필요한 확장성을 확보하기 위함이다.

## 🔍 프로젝트 특화 규칙

- **AI 관련 패턴**: [자동화 가능] OpenAI API 호출은 별도 서비스로 추상화하고 결과를 캐싱해야 한다(must). API 비용 최적화와 응답 시간 단축을 위함이다.
- **성능 중점 영역**: 콘텐츠 로딩과 AI 응답 시간을 최적화해야 한다(must). 사용자 경험에 직접적 영향을 미치는 핵심 요소이기 때문이다.
- **보안 고려사항**: [자동화 가능] API 키는 환경 변수로 관리하고 HTTPS 통신만 허용해야 한다(must). 민감한 정보 보호와 안전한 통신을 보장하기 위함이다.
- **확장성 요구사항**: 사용자와 콘텐츠 증가에 대비한 수평적 확장이 가능하도록 설계해야 한다(should). 향후 성장에 따른 인프라 요구사항 변화에 대응하기 위함이다.

## 🔄 규칙 개선 메커니즘

- **규칙 평가 지표**: 개발자 만족도 설문조사, 코드 리뷰 시 규칙 준수율 측정
- **피드백 수집 방법**: 격주 회고 미팅에서 규칙 개선 의견 수렴, GitHub Discussions 활용
- **규칙 개정 주기**: 분기별(3개월 단위) 정기 개정, 긴급 사항은 즉시 처리

## ⚙️ Cursor IDE 자동화 연계 지침

- 규칙 파일은 Cursor IDE의 `.cursor/rules/core/201-ai-lms-tech-stack/` 디렉토리에 저장하여 IDE가 자동으로 인식하도록 합니다.
- [자동화 가능] 태그가 붙은 규칙은 Cursor IDE의 자동 코드 생성 및 리뷰 기능과 연계됩니다.
- ESLint, Prettier, Black 등의 포맷팅 도구 설정은 프로젝트 루트에 위치시켜 IDE 통합을 활성화합니다.

## 🔗 참고 링크

- [React 18 공식 문서](https://react.dev)
- [Django REST Framework 가이드](https://www.django-rest-framework.org/)
- [AWS 클라우드 설계 패턴](https://aws.amazon.com/architecture/)
- [Cursor IDE 규칙 설정 가이드](https://cursor.sh/docs/rules)
